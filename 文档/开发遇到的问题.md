## 记录一下开发遇到的问题，以便面试吹牛

### 审批流程组件，节点id唯一问题
- 因为节点很长，id当时业务用的是生成时间戳的方式来生成唯一id的，因为增加节点的需求很多增加的那个节点代码很冗余，我把节点在data封装起来，这样$set的时候直接调用就好了。但是写完测试的时候发现节点是id是一样的，然后突然想到data里声明的那个节点应该是只初始化了一次，在调用的时候并不会被重新赋新的时间戳，也就是虽然写在data上是用的new Data()，但实际上调用的时候已经是一个生成好的固定值，所以这样是无效的。
- 更改方案就是换回来（不是），就是调用的时候先深拷贝一次，然后把里面的id重新用时间戳赋值，这样就可以了。

### vue2.6升2.7遇到的坑和解决方案
- mixin vue3其实也有mixin但已经不被提倡使用了，而且用的时候容易出错，一种解决方案是把之前mixin的js文本改成hooks函数，另一种是不要在setup里面用，单独定义一个script去用mixin，然后用获取组件实例（getCurrentInstance）的方案去获取mixin的方法。
- $emit -> defineEmit()
- $refs -> ref（直接获取到ref实例）
- provide inject 数据可响应
- attr -> useAttrs()
- watch computed写法改变， 新增watchEffect自动追踪数据
- props定义写法改变
- defineExpose()释放事件（或变量）给外部组件调用，否则undefined
- 以前的data现在无了 改成用ref或者reactive定义了，ref定义的东西获取值要加.value
- 生命周期的钩子名字变了，包括说之前总是用this代，现在已经没有this了，如果真的想用以前的this来做一些操作的话就是用getCurrentInstance()去获取组件的整个实例（作为这里的this）
- props的数据是只读的，computed简化写法也是只读的（getset都写就是可读写），watch有时候直接写那个变量是监听不到的，要用箭头函数包一下。


### 虚拟列表+优化
1. 虚拟列表的构成
  - 外部固定高度盒子
  - 内部模拟全部列表高度盒子（高度是模拟盒子的整个高度）
  - 真实显示区（用trasform.translateY()控制让显示区域一直在屏幕里）

2. 需要用到的变量
  - 外层盒子高度  boxH
  - 每个元素的高度 itemH
  - 整体个数 ListNum
  - 列表整体数据 list
  - 目前显示列表 nowList
  - 显示区域动态偏移量 offsetY

3. 大体思路
  - 获取当前页面的元素，根据外高/每个元素高+1取整对list数据进行切片 this.nowList = this.list.slice(0, Math.ceil(this.boxH / this.itemH) + 1)
  - 偏移量计算e.target.scrollTop是卷起高度， offsetY = e.target.scrollTop - (e.target.scrollTop % this.itemH)
  - 卷起的个数计算startIndex = Math.floor(e.target.scrollTop / this.itemH)

4. 优化
  - 上下缓存区：初始就在尾部添加缓存区，一次只加载固定列表项（比如5项），如果上下卷起高度超过缓存区个数，就扩大显示区的显示列表项个数
  - 在缓存的时候可以加个节流，防止频繁更新
  - 或者也可以触底更新，一般常见的解决方案也是触底的，计算scrollHeight-scrollTop是否大于容器外高度，大于等于则说明触底了，触底的时候再去请求加载数据，做一个懒加载。

5. 注意的点